/*
manacher：可以解决最长回文问题。
算法：
首先，将字符串的每个字符左右加入#，
并在s0位置加入*（如果字符串中本身含有这些，则换成未出现过的字符），
此时字符串的长度为len+len+3，
即加入了len+1个#和一个*; （比如：aba变成 *#a#b#a#）

得到一个p数组，该数组是基于新字符串进行的，
p[i]表示以 i 为中心的最长回文半径
p[i] - 1正好是原字符串中最长回文串的长度，如
S * # a # b # b # a # h # o # p # x # p #
p   1 2 1 2 5 2 1 2 1 2 1 2 1 2 1 4 1 2 1
*/
void manacher(char S[],int len) //manacher 函数
{
    for(int i=len;i>=0;--i) //将s扩大，中间加#，开头加*
    {
        S[i+i+2]=S[i];
        S[i+i+1]='#';
    }
    S[0]='*';
    int id,mx=0;  //mx代表以id为中心时，到达最远的位置
    for(int i=1;i<len+len+1;++i)
    {
        if(mx>i) p[i]=min(p[2*id-i],mx-i); //如果到达最远位置大于当前匹配的地方，则p[i]取min（id的对称点的p，到达最远距离-i）
        else p[i]=1; //如果i在mx右方，则p[i]=-1;
        while(S[i-p[i]] == S[i+p[i]])++p[i];   //判断i回文长度
        if(i+p[i]>mx) //看是否要更新最远距离，如果要，将此点作为中心。
        {
            id=i;
            mx=p[i]+i;
        }
    }
}
