多重背包问题：
有N种物品和容量为V的背包，若第i种物品，容量为v[i]，价值为w[i]，共有n[i]件。怎样装才能使背包内的物品总价值最大？
 
网上关于“多重背包”的资料倒是不少，但是关于怎么实现O(N*V)算法的资料，真得好少呀，关于“单调队列”那部分算法，又没说明得很清楚，看了几遍没看懂原理，只好自己动脑去想怎么实现O(N*V)算法。
 
若用F[i][j]表示对容量为j的背包，处理完前i种物品后，背包内物品可达到的最大总价值，并记m[i] = min(n[i], j / v[i])。放入背包的第i种物品的数目可以是：0、1、2……，可得：
F[i][j] = max { F[i - 1] [j C k * v[i] ] + k * w[i] }  (0 <= k <= m[i])       ㈠
   
如何在O(1)时间内求出F[i][j]呢？
先看一个例子：取m[i] = 2, v[i] = v, w[i] = w, V > 9 * v，
并假设 f(j) = F[i - 1][j]，观察公式右边要求最大值的几项：
j = 6*v:   f(6*v)、f(5*v)+w、f(4*v)+2*w 这三个中的最大值
j = 5*v:   f(5*v)、f(4*v)+w、f(3*v)+2*w 这三个中的最大值
j = 4*v:   f(4*v)、f(3*v)+w、f(2*v)+2*w 这三个中的最大值
显然，公式㈠右边求最大值的几项随j值改变而改变，但如果将j = 6*v时，每项减去6*w，j=5*v时，每项减去5*w，j=4*v时，每项减去4*w，就得到：
j = 6*v:   f(6*v)-6*w、f(5*v)-5*w、f(4*v)-4*w 这三个中的最大值
j = 5*v:   f(5*v)-5*w、f(4*v)-4*w、f(3*v)-3*w 这三个中的最大值
j = 4*v:   f(4*v)-4*w、f(3*v)-3*w、f(2*v)-2*w 这三个中的最大值
很明显，要求最大值的那些项，有很多重复。
 
根据这个思路，可以对原来的公式进行如下调整：
假设d = v[i]，a = j / d，b = j % d，即 j = a * d + b，代入公式㈠，并用k替换a - k得：
F[i][j] = max { F[i - 1] [b + k * d] - k * w[i] } + a * w[i]   (a C m[i] <= k <= a)    ㈡
 
对F[i - 1][y] （y= b  b+d  b+2d  b+3d  b+4d  b+5d  b+6d  …  j）
F[i][j]就是求j的前面m[i] + 1个数对应的F[i - 1] [b + k * d] - k * w[i]的最大值，加上a * w[i]，如果将F[i][j]前面所有的F[i - 1][b + k * d] C k * w放入到一个队列，那么，F[i][j]就是求这个队列最大长度为m[i] + 1时，队列中元素的最大值，加上a * w[i]。因而原问题可以转化为：O(1)时间内求一个队列的最大值。
 
该问题可以这样解决：
① 用另一个队列B记录指定队列的最大值（或者记录最大值的地址），并通过下面两个操作保证队列B的第一个元素（或其所指向的元素）一定是指定队列的当前最大值。
② 当指定队列有元素M进入时，删除队列B中的比M小的（或队列B中所指向的元素小等于M的）所有元素，并将元素M（或其地址）存入队列B。
③ 当指定队列有元素M离开时，队列B中的第一个元素若与M相等（或队列B第一个元素的地址与M相等），则队列B的第一个元素也离队。
 
经过上述处理，可以保证队列B中的第一个元素（或其指向的元素）一定是所指定队列所有元素的最大值。显然队列B的元素（或其所指向的元素）是单调递减的，这应该就是《背包九讲》中的提到的“单调队列”吧，初看的时候被这个概念弄得稀里糊涂，网上的资料提到“维护队列的最大值”，刚开始还以为是维护这个单调队列的最大值，对其采用的算法，越看越糊涂。其实，只要明白用一个“辅助队列”，求另一个队列的最值，那么具体的算法，和该“辅助队列”的性质（单调变化），都很容易推导出来。
 
在多重背包问题中，所有要进入队列的元素个数的上限值是已知的，可以直接用一个大数组模拟队列。

//“多重背包”通用模板  
const int MAX_V = 100004;  
//v、n、w：当前所处理的这类物品的体积、个数、价值  
//V：背包体积， MAX_V：背包的体积上限值  
//f[i]：体积为i的背包装前几种物品，能达到的价值上限。  
inline void pack(int f[], int V, int v, int n, int w)  
{  
  if (n == 0 || v == 0) return;  
  if (n == 1) {               //01背包  
    for (int i = V; i >= v; --i)  
      if (f[i] < f[i - v] + w) f[i] = f[i - v] + w;  
    return;  
  }  
  if (n * v >= V - v + 1) {   //完全背包(n >= V / v)  
    for (int i = v; i <= V; ++i)  
      if (f[i] < f[i - v] + w) f[i] = f[i - v] + w;  
    return;      
  }  
  
  int va[MAX_V], vb[MAX_V];   //va/vb: 主/辅助队列  
  for (int j = 0; j < v; ++j) {     //多重背包  
    int *pb = va, *pe = va - 1;     //pb/pe分别指向队列首/末元素  
    int *qb = vb, *qe = vb - 1;     //qb/qe分别指向辅助队列首/末元素    
    for (int k = j, i = 0; k <= V; k += v, ++i) {  
      if (pe  == pb + n) {       //若队列大小达到指定值，第一个元素X出队。  
        if (*pb == *qb) ++qb;   //若辅助队列第一个元素等于X，该元素也出队。   
        ++pb;  
      }  
      int tt = f[k] - i * w;  
      *++pe = tt;                  //元素X进队  
      //删除辅助队列所有小于X的元素，qb到qe单调递减，也可以用二分法  
      while (qe >= qb && *qe < tt) --qe;  
      *++qe = tt;              //元素X也存放入辅助队列          
      f[k] = *qb + i * w;      //辅助队列首元素恒为指定队列所有元素的最大值  
    }  
  }  
}  