# 二维凸包
```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
#define N 1010
struct Point{
    double x,y;
    Point(){}
    Point(double _x,double _y):x(_x),y(_y){}
    bool operator<(const Point &p)const
    {
        return x<p.x||x==p.x&&y<p.y;
    }
}P[N],sta[N];
int n;
const double eps=1e-8;
double cross(Point p0,Point p1,Point p2)
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
double area(Point P[],int n)
{
    P[n+1]=P[1];
    double ans=0;
    for(int i=1;i<=n;++i)
        ans+=cross(P[1],P[i],P[i+1]);
    return -ans/2;
}
void Reverse(Point P[],int n)
{
    for(int i=1;i<=(n+1)/2;++i)
        swap(P[i],P[n-i+1]);
}
void Graham()
{
    sort(P+1,P+n+1);
    int top=2;
    sta[1]=P[1];sta[2]=P[2];
    for(int i=3;i<=n;++i)
    {
        while(top>1&&cross(sta[top-1],sta[top],P[i])>-eps) --top;
        sta[++top]=P[i];
    }
    int k=top;
    for(int i=n-1;i>0;--i)
    {
        while(top>k&&cross(sta[top-1],sta[top],P[i])>-eps) --top;
        sta[++top]=P[i];
    }
    if(top>1) --top;
    for(int i=1;i<=top;++i) P[i]=sta[i];
    n=top;
}
double dis(Point p1,Point p2)
{
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}
int main()
{
    double r;
    while(scanf("%d%lf",&n,&r)!=EOF)
    {
        for(int i=1;i<=n;++i)
            scanf("%lf%lf",&P[i].x,&P[i].y);
        if(area(P,n)) Reverse(P,n);
        Graham();
        double len=0;
        P[n+1]=P[1];
        for(int i=1;i<=n;++i)
            len+=dis(P[i],P[i+1]);
        len+=acos(-1)*r*2;
        printf("%.0f\n",len);
    }
    return 0;
}
```

# 半平面交（n2）
```
//--------------
//点的编号从1到n
//--------------
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 110
struct Point{
    double x,y;
    Point(){}
    Point(double a,double b):x(a),y(b){}
}P[N],b1[N],b2[N];
struct Line{
    Point s,t;
    Line(){}
    Line(Point a,Point b):s(a),t(b){}
};
int n,m;
const double eps=1e-8;
int sig(double x)
{
    if(x>eps) return 1;
    if(x<-eps) return -1;
    return 0;
}
double cross(Point p0,Point p1,Point p2)
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
Point intersect(Line l1,Line l2)
{
    double u=cross(l2.s,l2.t,l1.s),v=cross(l2.t,l2.s,l1.t);
    Point p;
    p.x=(u*l1.t.x+v*l1.s.x)/(u+v);
    p.y=(u*l1.t.y+v*l1.s.y)/(u+v);
    return p;
}
Line Move(Line l,double r)//将直线向内推进r
{
    double k,dx,dy,tx,ty;
    dx=l.t.x-l.s.x;
    dy=l.t.y-l.s.y;
    k=r/sqrt(dx*dx+dy*dy);
    tx=k*dy;ty=-k*dx;
    l.s.x+=tx;l.s.y+=ty;
    l.t.x+=tx;l.t.y+=ty;
    return l;
}
void cut(Line l)
{
    int cnt=0;
    Line l1;
    b1[0]=b1[m];b1[m+1]=b1[1];
    for(int i=1;i<=m;++i)
    {
        if(sig(cross(l.s,l.t,b1[i]))<=0)
            b2[++cnt]=b1[i];
        else
        {
            if(sig(cross(l.s,l.t,b1[i-1]))<0)
                b2[++cnt]=intersect(l,Line(b1[i-1],b1[i]));
            if(sig(cross(l.s,l.t,b1[i+1]))<0)
                b2[++cnt]=intersect(l,Line(b1[i],b1[i+1]));
        }
    }
    for(int i=1;i<=cnt;++i)
        b1[i]=b2[i];
    m=cnt;
}
bool solve()
{
    P[n+1]=P[1];
    m=n;
    for(int i=1;i<=n;++i) b1[i]=P[i];
    for(int i=1;i<=n;++i)
    {
        cut(Line(P[i],P[i+1]));
        if(m==0) break;
    }
    if(m) return true;
    else return false;
}
double area(Point P[],int n)
{
    double ans=0;
    P[n+1]=P[1];
    for(int i=1;i<=n;++i)
        ans+=cross(P[1],P[i],P[i+1]);
    return -ans/2;
}
void Reverse(Point P[],int n)
{
    for(int i=1;i<=(n+1)/2;++i)
        swap(P[i],P[n-i+1]);
}
int main()
{
    int ca;
    scanf("%d",&ca);
    while(ca--)
    {
        scanf("%d",&n);
        for(int i=1;i<=n;++i)
            scanf("%lf%lf",&P[i].x,&P[i].y);
        if(area(P,n)<0) Reverse(P,n);
        if(solve()) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
```

# 半平面交（nlogn)
```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
#define N 20010
struct Point{
    double x,y;
    Point(){}
    Point(double a,double b):x(a),y(b){}
    void f(double &a,double &b)
    {
        a=x;b=y;
    }
    void input()
    {
        scanf("%lf%lf",&x,&y);
    }
    void output()
    {
        printf("%.1f %.1f\n",x,y);
    }
}P[N];
struct Line{
    Point s,t;
    double angle;
    Line(){}
    Line(Point a,Point b):s(a),t(b){}
    void get_angle()
    {
        angle=atan2(t.y-s.y,t.x-s.x);
    }
}L[N];
int n,m;
int que[N];
const double eps=1e-8;
int sig(double x)
{
    if(x>eps) return 1;
    if(x<-eps) return -1;
    return 0;
}
double cross(Point p0,Point p1,Point p2)
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
bool cmp(Line l1,Line l2)
{
    int t=sig(l1.angle-l2.angle);
    if(t>0) return true;
    else if(t<0) return false;
    else if(sig(cross(l1.s,l1.t,l2.s))>0) return true;
    else return false;
}
Point intersect(Line l1,Line l2)
{
    double u=cross(l2.s,l2.t,l1.s),v=cross(l2.t,l2.s,l1.t);
    Point p;
    p.x=(u*l1.t.x+v*l1.s.x)/(u+v);
    p.y=(u*l1.t.y+v*l1.s.y)/(u+v);
    return p;
}
Line Move(Line l,double r)//将直线向内推进r
{
    double k,dx,dy,tx,ty;
    dx=l.t.x-l.s.x;
    dy=l.t.y-l.s.y;
    k=r/sqrt(dx*dx+dy*dy);
    tx=k*dy;ty=-k*dx;
    l.s.x+=tx;l.s.y+=ty;
    l.t.x+=tx;l.t.y+=ty;
    return l;
}
bool judge(Line l,Line l1,Line l2)
{
    Point p=intersect(l1,l2);
    if(sig(cross(l.s,l.t,p))>0) return true;
    else return false;
}
void solve(Line L[],int n)
{
    sort(L+1,L+n+1,cmp);
    int cnt=1;
    for(int i=2;i<=n;++i)
        if(sig(L[i].angle-L[i-1].angle)!=0)
            L[++cnt]=L[i];
    n=cnt;
    int head=1,tail=2;
    que[1]=1;que[2]=2;
    for(int i=3;i<=n;++i)
    {
        while(head<tail&&judge(L[i],L[que[tail]],L[que[tail-1]])) --tail;
        while(head<tail&&judge(L[i],L[que[head]],L[que[head+1]])) ++head;
        que[++tail]=i;
    }
    while(head<tail&&judge(L[que[head]],L[que[tail]],L[que[tail-1]])) --tail;
    while(head<tail&&judge(L[que[tail]],L[que[head]],L[que[head+1]])) ++head;
    m=0;
    if(head==tail) return;
    que[tail+1]=que[head];
    for(int i=head;i<=tail;++i)
        P[++m]=intersect(L[que[i]],L[que[i+1]]);
}
double area(Point P[],int n)
{
    P[n+1]=P[1];
    double ans=0;
    for(int i=1;i<=n;++i)
        ans+=cross(P[1],P[i],P[i+1]);
    return -ans/2;
}
int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        L[1]=Line(Point(0,0),Point(0,10000));L[1].get_angle();
        L[2]=Line(Point(0,10000),Point(10000,10000));L[2].get_angle();
        L[3]=Line(Point(10000,10000),Point(10000,0));L[3].get_angle();
        L[4]=Line(Point(10000,0),Point(0,0));L[4].get_angle();
        for(int i=5;i<=n+4;++i)
        {
            L[i].t.input();L[i].s.input();L[i].get_angle();
        }
        solve(L,n+4);
        printf("%.1f\n",area(P,m)+eps);
    }
    return 0;
}
```

# 多边形重心
```
#include <cstdiO>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
#define N 1000010
struct Point{
    double x,y;
    Point(){}
    Point(double _x,double _y):x(_x),y(_y){}
    void input()
    {
        scanf("%lf%lf",&x,&y);
    }
}P[N];
const double eps=1e-8;
int n;
double cross(Point p0,Point p1,Point p2)
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
//求多边形重心的思路把多边形划分为三角形，算出三角形的重心
//三角形的质量都集中在重心，可以把三角形看成一个点
//然后就变成了求一些离散的质点的重心，套用重心公式即可
Point center(Point P[],int n)
{
    P[n]=P[0];
    double area,sum_area=0,sum_x=0,sum_y=0;
    for(int i=0;i<n;++i)
    {
        area=cross(P[0],P[i],P[i+1])/2;
        sum_area+=area;
        sum_x+=(P[0].x+P[i].x+P[i+1].x)/3*area;
        sum_y+=(P[0].y+P[i].y+P[i+1].y)/3*area;
    }
    return Point(sum_x/sum_area,sum_y/sum_area);
}
int main()
{
    int ca;
    scanf("%d",&ca);
    while(ca--)
    {
        scanf("%d",&n);
        for(int i=0;i<n;++i) P[i].input();
        Point p;
        p=center(P,n);
        printf("%.2f %.2f\n",p.x+eps,p.y+eps);
    }
    return 0;
}
```

# 矩形面积并
```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
using namespace std;
#define lson node<<1,s,mid
#define rson node<<1|1,mid+1,t
#define lnode node<<1
#define rnode node<<1|1
#define M(x) memset(x,0,sizeof(x));
#define N 110
struct rec{
    int l,r,w;
    double x1,x2,h;
    rec(){}
    rec(double a,double b,double c,int d)
    {
        x1=a;x2=b;h=c;w=d;
    }
    bool operator<(const rec &a)const
    {
        return (h<a.h)||(h==a.h)&&(w>a.w);
    }
}a[N*2];
int change[N*8];
double seg[N*8],b[N*2],fx[N*2];
int n;
map<double,int>mp;
void pushup(int node,int s,int t)
{
    if(change[node])
        seg[node]=fx[t+1]-fx[s];
    else if(s!=t)
        seg[node]=seg[lnode]+seg[rnode];
    else seg[node]=0;

}
void updata(int node,int s,int t,int l,int r,int w)
{
    if(l<=s&&t<=r)
    {
        change[node]+=w;
        pushup(node,s,t);
    }
    else
    {
        int mid=s+t>>1;
        if(l<=mid) updata(lson,l,r,w);
        if(mid<r) updata(rson,l,r,w);
        pushup(node,s,t);
    }
}
int main()
{
    int ca=0;
    double x1,x2,y1,y2;
    M(seg);M(change);
    while(scanf("%d",&n),n)
    {
        for(int i=0;i<n;++i)
        {
            scanf("%lf%lf%lf%lf",&x1,&y1,&x2,&y2);
            b[i<<1]=x1;b[i<<1|1]=x2;
            a[i<<1]=rec(x1,x2,y1,1);
            a[i<<1|1]=rec(x1,x2,y2,-1);
        }
        sort(b,b+2*n);
        int tot=1;
        mp.clear();
        mp[b[0]]=1;fx[1]=b[0];
        for(int i=1;i<2*n;++i)
            if(b[i]!=b[i+1])
            {
                mp[b[i]]=++tot;
                fx[tot]=b[i];
            }
        for(int i=0;i<2*n;++i)
            a[i].l=mp[a[i].x1],a[i].r=mp[a[i].x2];
        sort(a,a+2*n);
        double ans=0;
        for(int i=0;i<2*n;++i)
        {
            updata(1,1,tot-1,a[i].l,a[i].r-1,a[i].w);
            ans+=seg[1]*(a[i+1].h-a[i].h);
        }
        printf("Test case #%d\nTotal explored area: %.2f\n\n",++ca,ans);
    }
    return 0;
}
```

# 矩形周长并
```
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
#define lson node<<1,s,mid
#define rson node<<1|1,mid+1,t
#define lnode node<<1
#define rnode node<<1|1
#define M(x) memset(x,0,sizeof(x));
#define N 20010
struct rec{
    int x1,x2,h,w;
    rec(){}
    rec(int a,int b,int c,int d)
    {
        x1=a;x2=b;h=c;w=d;
    }
    bool operator<(const rec &a)const
    {
        return (h<a.h)||(h==a.h)&&(w>a.w);
    }
}a[N];
int seg[N*4],change[N*4],sum[N*4];
bool lseg[N*4],rseg[N*4];
int n;
void pushup(int node,int s,int t)
{
    if(change[node])
    {
        seg[node]=t-s+1;
        sum[node]=2;
        lseg[node]=rseg[node]=1;
    }
    else
    {
        if(s!=t)
        {
            seg[node]=seg[lnode]+seg[rnode];
            lseg[node]=lseg[lnode];
            rseg[node]=rseg[rnode];
            sum[node]=sum[lnode]+sum[rnode];
            if(rseg[lnode]&&lseg[rnode])
                sum[node]-=2;
        }
        else seg[node]=lseg[node]=rseg[node]=sum[node]=0;
    }
}
void updata(int node,int s,int t,int l,int r,int w)
{
    if(l<=s&&t<=r)
    {
        change[node]+=w;
        pushup(node,s,t);
    }
    else
    {
        int mid=s+t>>1;
        if(l<=mid) updata(lson,l,r,w);
        if(mid<r) updata(rson,l,r,w);
        pushup(node,s,t);
    }
}
int main()
{
    int s,t,x1,x2,y1,y2;
    M(seg);M(lseg);M(rseg);M(change);M(sum);
    while(scanf("%d",&n)!=EOF)
    {
        s=N;t=-N;
        for(int i=0;i<n;++i)
        {
            scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
            a[i<<1]=rec(x1,x2,y1,1);
            a[i<<1|1]=rec(x1,x2,y2,-1);
            s=min(s,x1);t=max(t,x2);
        }
        sort(a,a+2*n);
        int ans=0,last=0;
        //printf("ok\n");
        for(int i=0;i<2*n;++i)
        {
            updata(1,s,t,a[i].x1,a[i].x2-1,a[i].w);
            ans+=abs(seg[1]-last)+sum[1]*(a[i+1].h-a[i].h);
            last=seg[1];
        }
        printf("%d\n",ans);
    }
}
```

# 最小费马点
```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
#define N 110
#define inf 10010
struct Point{
    double x,y;
}a[N];
const int fx[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
int n;
double dis(Point p1,Point p2)
{
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}
double get_sum(Point p)
{
    double ans=0;
    for(int i=1;i<=n;++i)
        ans+=dis(a[i],p);
    return ans;
}
double solve()
{
    Point p,p1,p2;
    p.x=p.y=0;
    double ans=get_sum(p);
    int x1=inf,y1=inf,x2=-inf,y2=-inf;
    for(int i=1;i<=n;++i)
    {
        x1=min(x1,(int)a[i].x);
        y1=min(y1,(int)a[i].y);
        x2=max(x2,(int)a[i].x);
        y2=max(y2,(int)a[i].y);
    }
    double diff,minn,d;
    int i;
    srand(0);
    for(int z=1;z<=20;++z)
    {
        p1.x=x1+rand()%(x2-x1+1);
        p1.y=y1+rand()%(y2-y1+1);
        minn=get_sum(p1);
        diff=10000;
        while(diff>0.001)
        {
            for(i=0;i<4;++i)
            {
                p2.x=p1.x+fx[i][0]*diff;
                p2.y=p1.y+fx[i][1]*diff;
                d=get_sum(p2);
                if(d<minn)
                {
                    minn=d;p1=p2;break;
                }
            }
            if(i==4) diff*=0.9;
        }
        if(minn<ans) ans=minn;
    }
    return ans;
}
int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        for(int i=1;i<=n;++i)
            scanf("%lf%lf",&a[i].x,&a[i].y);
        printf("%.0f\n",solve());
    }
    return 0;
}
```

# 最近点对
```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
#define N 100010
const double inf=1e20;
struct Point{
    double x,y;
}a[N];
int tmp[N];
int n;
bool cmpxy(Point &p1,Point &p2)
{
    return (p1.x<p2.x)||(p1.x==p2.x&&p1.y<p2.y);
}
bool cmpy(int i,int j)
{
    return a[i].y<a[j].y;
}
double dis(Point &p1,Point &p2)
{
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}
double closest_pair(int l,int r)
{
    double d=inf;
    if(l==r) return d;
    if(l+1==r) return dis(a[l],a[r]);
    int mid=l+r>>1;
    double d1=closest_pair(l,mid);
    double d2=closest_pair(mid+1,r);
    d=min(d1,d2);
    int k=0;
    for(int i=l;i<=r;++i)
        if(fabs(a[i].x-a[mid].x)<=d)
            tmp[++k]=i;
    sort(tmp+1,tmp+k+1,cmpy);
    for(int i=1;i<k;++i)
        for(int j=i+1;j<=k&&a[tmp[j]].y-a[tmp[i]].y<d;++j)
            d=min(d,dis(a[tmp[i]],a[tmp[j]]));
    return d;
}
int main()
{
    while(scanf("%d",&n),n)
    {
        for(int i=1;i<=n;++i)
            scanf("%lf%lf",&a[i].x,&a[i].y);
        sort(a+1,a+n+1,cmpxy);
        double ans=closest_pair(1,n);
        if(ans<=10000) printf("%.4f\n",ans);
        else printf("INFINITY\n");
    }
    return 0;
}
```

# 最小圆覆盖
```
#include <cstdio>
#include <cmath>
#include <cstring>
#include <algorithm>
using namespace std;
#define N 510
const double eps=1e-8;
struct Point{
    double x,y;
}a[N];
int n;
double dis(Point p1,Point p2)
{
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}
Point circumcenter(Point p1,Point p2,Point p3)//求三角形外心
{
    Point p;
    double a1=p2.x-p1.x,b1=p2.y-p1.y,c1=(a1*a1+b1*b1)/2;
    double a2=p3.x-p1.x,b2=p3.y-p1.y,c2=(a2*a2+b2*b2)/2;
    double d=a1*b2-a2*b1;
    p.x=p1.x+(c1*b2-c2*b1)/d;
    p.y=p1.y+(a1*c2-a2*c1)/d;
    return p;
}
void min_cover_circle(Point p[],int n,Point &c,double &r)
{
    random_shuffle(a+1,a+n+1);//随机化序列
    c=a[1];r=0;
    for(int i=2;i<=n;++i)
        if(dis(p[i],c)>r+eps)//第一个点
        {
            c=p[i];r=0;
            for(int j=1;j<i;++j)
                if(dis(p[j],c)>r+eps)//第二个点
                {
                    c.x=(p[i].x+p[j].x)/2;
                    c.y=(p[i].y+p[j].y)/2;
                    r=dis(p[i],c);
                    for(int k=1;k<j;++k)
                        if(dis(p[k],c)>r+eps)//第三个点
                        {
                            c=circumcenter(p[i],p[j],p[k]);
                            r=dis(p[i],c);
                        }
                }
        }
}
int main()
{
    Point c;
    double r;
    while(scanf("%d",&n),n)
    {
        for(int i=1;i<=n;++i)
            scanf("%lf%lf",&a[i].x,&a[i].y);
        min_cover_circle(a,n,c,r);
        printf("%.2f %.2f %.2f\n",c.x,c.y,r);
    }
}
```

# 圆与多边形面积交
```
#include<algorithm>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iostream>
using namespace std;
struct Point{
    double x,y;
    Point(){}
    Point(double x0,double y0):x(x0),y(y0){}
}p[200005];
struct Line{
    Point s,e;
    Line(){}
    Line(Point s0,Point e0):s(s0),e(e0){}
};
int n;
double R;
const double eps=1e-8;
const double Pi=acos(-1);
double sgn(double x){
    if (x>eps) return 1.0;
    if (x<-eps) return -1.0;
    return 0;
}
Point operator *(Point p1,double x){
    return Point(p1.x*x,p1.y*x);
}
Point operator /(Point p1,double x){
    return Point(p1.x/x,p1.y/x);
}
double operator /(Point p1,Point p2){
    return p1.x*p2.x+p1.y*p2.y;
}
double operator *(Point p1,Point p2){
    return p1.x*p2.y-p1.y*p2.x;
}
Point operator +(Point p1,Point p2){
    return Point(p1.x+p2.x,p1.y+p2.y);
}
Point operator -(Point p1,Point p2){
    return Point(p1.x-p2.x,p1.y-p2.y);
}
double dis(Point p1){
    return sqrt(p1.x*p1.x+p1.y*p1.y);
}
double dis(Point p1,Point p2){
    return dis(Point(p1.x-p2.x,p1.y-p2.y));
}
double sqr(double x){
    return x*x;
}
double dist_line(Line p){
    double A,B,C,dist;
    A=p.s.y-p.e.y;
    B=p.s.x-p.e.x;
    C=p.s.x*p.e.y-p.s.y*p.e.x;
    dist=fabs(C)/sqrt(sqr(A)+sqr(B));
    return dist;
}
double get_cos(double a,double b,double c){
    return (b*b+c*c-a*a)/(2*b*c);
}
double get_angle(Point p1,Point p2){
    if (!sgn(dis(p1))||!sgn(dis(p2))) return 0.0;
    double A,B,C;
    A=dis(p1);
    B=dis(p2);
    C=dis(p1,p2);
    if (C<=eps) return 0.0;
    return acos(get_cos(C,A,B));
}
Point get_point(Point p){
    double T=sqr(p.x)+sqr(p.y);
    return Point(sgn(p.x)*sqrt(sqr(p.x)/T),sgn(p.y)*sqrt(sqr(p.y)/T));
}
double S(Point p1,Point p2,Point p3){
    return fabs((p2-p1)*(p3-p1))/2;
}
double work(Point p1,Point p2,Point O){
    p1=p1-O;p2=p2-O;
    O=Point(0,0);
    double f=sgn(p1*p2),res=0;
    if (!sgn(f)||!sgn(dis(p1))||!sgn(dis(p2))) return 0.0;
    double l=dist_line(Line(p1,p2));
    double a=dis(p1);
    double b=dis(p2);
    double c=dis(p1,p2);
    if (a<=R&&b<=R){
        return fabs(p1*p2)/2.0*f;
    }
    if (a>=R&&b>=R&&l>=R){
        double ang=get_angle(p1,p2);
        return fabs((ang/(2.0))*(R*R))*f;
    }
    if (a>=R&&b>=R&&l<=R&&(get_cos(a,b,c)<=0||get_cos(b,a,c)<=0)){
        double ang=get_angle(p1,p2);
        return fabs((ang/(2.0))*(R*R))*f;
    }
    if (a>=R&&b>=R&&l<=R&&(get_cos(a,b,c)>0&&get_cos(b,a,c)>0)){
        double dist=dist_line(Line(p1,p2));
        double len=sqrt(sqr(R)-sqr(dist))*2.0;
        double ang1=get_angle(p1,p2);
        double cos2=get_cos(len,R,R);
        res+=fabs(len*dist/2.0);
        double ang2=ang1-acos(cos2);
        res+=fabs((ang2/(2))*(R*R));
        return res*f;
    }
    if ((a>=R&&b<R)||(a<R&&b>=R)){
        if (b>a) swap(a,b),swap(p1,p2);
        double T=sqr(p1.x-p2.x)+sqr(p1.y-p2.y);
        Point u=Point(sgn(p1.x-p2.x)*sqrt(sqr(p1.x-p2.x)/T),sgn(p1.y-p2.y)*sqrt(sqr(p1.y-p2.y)/T));
        double dist=dist_line(Line(p1,p2));
        double len=sqrt(R*R-dist*dist);
        double len2=sqrt(sqr(dis(p2))-sqr(dist));
        if (fabs(dis(p2+u*len2)-dist)<=eps) len+=len2;
        else len-=len2;
        Point p=p2+u*len;
        res+=S(O,p2,p);
        double ang=get_angle(p1,p);
        res+=fabs((ang/2.0)*R*R);
        return res*f;
    }
    return 0;
}
int main(){
    Point O=Point(0,0);
    while (scanf("%lf",&R)!=EOF){
        scanf("%d",&n);
        for (int i=1;i<=n;i++)//˳ʱ֫Ŧʱ֫߹ࠉááá
         scanf("%lf%lf",&p[i].x,&p[i].y);
        p[n+1]=p[1];
        double ans=0;
        for (int i=1;i<=n;i++)
         ans+=work(p[i],p[i+1],O);
        ans=fabs(ans);
        printf("%.2f\n",ans);
    }
}
```

# 旋转卡壳——求两凸包的最近点对距离
```
/*
---------------
点集编号从0开始
---------------
*/
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
#define N 10010
struct Point{
    double x,y;
    Point(){}
    Point(double _x,double _y):x(_x),y(_y){}
    void input()
    {
        scanf("%lf%lf",&x,&y);
    }
}P[N],Q[N],b[N];
int n,m;
const double eps=1e-8;
const double inf=1e20;
double cross(Point p0,Point p1,Point p2)
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
double dot(Point p0,Point p1,Point p2)
{
    return (p1.x-p0.x)*(p2.x-p0.x)+(p1.y-p0.y)*(p2.y-p0.y);
}
double area(Point a[],int n)
{
    double ans=0;
    a[n]=a[0];
    for(int i=0;i<n;++i)
        ans+=cross(a[0],a[i],a[i+1]);
    return ans/2.0;
}
void Reverse(Point a[],int n)
{
    for(int i=0;i<n;++i) b[i]=a[i];
    for(int i=0;i<n;++i) a[i]=b[n-i-1];
}
double dis(Point p1,Point p2)
{
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}
//计算p3到线段p1,p2的最短距离
double get_dis(Point p1,Point p2,Point p3)
{
    if(dis(p1,p2)<eps) return dis(p1,p3);
    if(dot(p1,p2,p3)<-eps) return dis(p1,p3);
    if(dot(p2,p1,p3)<-eps) return dis(p2,p3);
    return fabs(cross(p1,p2,p3))/dis(p1,p2);
}
//计算线段p1,p2到线段p3,p4的最短距离
double get_dis(Point p1,Point p2,Point p3,Point p4)
{
    return min(get_dis(p1,p2,p3),get_dis(p1,p2,p4));
}
//旋转卡壳
double solve(Point P[],Point Q[],int n,int m)
{
    int yP=0,yQ=0;
    //找出P中y最小的点和Q中y最大的点
    for(int i=0;i<n;++i)
        if(P[i].y<P[yP].y) yP=i;
    for(int i=0;i<m;++i)
        if(Q[i].y>Q[yQ].y) yQ=i;
    P[n]=P[0];Q[m]=Q[0];
    double tmp,ans=inf;
    for(int i=0;i<n;++i)
    {
        while(tmp=cross(P[yP+1],Q[yQ+1],P[yP])-cross(P[yP+1],Q[yQ],P[yP])>eps)
            yQ=(yQ+1)%m;
        if(tmp<-eps) ans=min(ans,get_dis(P[yP],P[yP+1],Q[yQ]));
        else ans=min(ans,get_dis(P[yP],P[yP+1],Q[yQ],Q[yQ+1]));
        yP=(yP+1)%n;
    }
    return ans;
}
int main()
{
    while(scanf("%d%d",&n,&m),n)
    {
        for(int i=0;i<n;++i) P[i].input();
        for(int i=0;i<m;++i) Q[i].input();
        //将P和Q按顺时针排列
        if(area(P,n)<-eps) Reverse(P,n);
        if(area(Q,m)<-eps) Reverse(Q,m);
        //求出分别绕两个多边形旋转的最小值
        printf("%.5f\n",min(solve(P,Q,n,m),solve(Q,P,m,n)));
    }
    return 0;
}
```

# 旋转卡壳——求凸包直径（最远点对）
```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
#define N 50010
struct Point{
    double x,y;
    Point(){}
    Point(double _x,double _y):x(_x),y(_y){}
    bool operator<(const Point &a)const
    {
        return x<a.x||x==a.x&&y<a.y;
    }
    void input()
    {
        scanf("%lf%lf",&x,&y);
    }
}P[N],sta[N];
int n;
const double eps=1e-8;
double cross(Point p0,Point p1,Point p2)
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
double area(Point P[],int n)
{
    double ans=0;
    P[n]=P[0];
    for(int i=0;i<n;++i)
        ans+=cross(P[0],P[i],P[i+1]);
    return -ans/2;
}
void Reverse(Point P[],int n)
{
    for(int i=0;i<(n+1)/2;++i)
        swap(P[i],P[n-i-1]);
}
double dis2(Point p1,Point p2)
{
    return (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y);
}
double solve(Point P[],int n)
{
    int i1=0,i2=0;
    P[n]=P[0];
    for(int i=1;i<n;++i)
    {
        if(P[i].y>P[i1].y) i1=i;
        if(P[i].y<P[i2].y) i2=i;
    }
    double ans=0,tmp;
    for(int i=0;i<n;++i)
    {
        while(tmp=cross(P[i1],P[i2],P[i1+1])-cross(P[i1],P[i2+1],P[i1+1])<-eps)
            i2=(i2+1)%n;
        ans=max(ans,max(dis2(P[i1],P[i2]),dis2(P[i1+1],P[i2+1])));
        i1=(i1+1)%n;
    }
    return ans;
}
void Graham()
{
    sort(P,P+n);
    int top=1;
    sta[0]=P[0];sta[1]=P[1];
    for(int i=2;i<n;++i)
    {
        while(top&&cross(sta[top-1],sta[top],P[i])>-eps) --top;
        sta[++top]=P[i];
    }
    int k=top;
    for(int i=n-2;i>=0;--i)
    {
        while(top>k&&cross(sta[top-1],sta[top],P[i])>-eps) --top;
        sta[++top]=P[i];
    }
    if(top) top--;
    for(int i=0;i<=top;++i) P[i]=sta[i];
    n=top+1;
}
int main()
{
    while(scanf("%d",&n)!=EOF)
    {
        for(int i=0;i<n;++i) P[i].input();
        if(area(P,n)<0) Reverse(P,n);
        Graham();
        printf("%.0f\n",solve(P,n));
    }
    return 0;
}
```

# 旋转卡壳——求凸包上最大三角形面积
```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
#include <set>
#include <utility>
using namespace std;
#define N 50010
struct Point{
    double x,y;
    Point(){}
    Point(double _x,double _y):x(_x),y(_y){}
    bool operator<(const Point &a)const
    {
        return x<a.x||x==a.x&&y<a.y;
    }
    void input()
    {
        scanf("%lf%lf",&x,&y);
    }
}P[N],sta[N];
int n;
bool f[N];
const double eps=1e-8;
double cross(Point p0,Point p1,Point p2)
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
double solve()
{
    if(n<3) return 0;
    double ans=0;
    int i=0,j,k;
    P[n]=P[0];
    for(int i=0;i<n;++i)
    {
        j=(i+1)%n;k=(j+1)%n;
        while(i!=k)
        {
            while(j!=k&&cross(P[i],P[k],P[j])-cross(P[i],P[k],P[j+1])<-eps)
                j=(j+1)%n;
            ans=max(ans,cross(P[i],P[k],P[j])/2);
            k=(k+1)%n;
        }
    }
    return ans;
}
void Graham()
{
    sort(P,P+n);
    int top=1;
    sta[0]=P[0];sta[1]=P[1];
    for(int i=2;i<n;++i)
    {
        while(top&&cross(sta[top-1],sta[top],P[i])>-eps) --top;
        sta[++top]=P[i];
    }
    int k=top;
    for(int i=n-2;i>=0;--i)
    {
        while(top>k&&cross(sta[top-1],sta[top],P[i])>-eps) --top;
        sta[++top]=P[i];
    }
    if(top) --top;
    for(int i=0;i<=top;++i) P[i]=sta[i];
    n=top+1;
}
int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    while(scanf("%d",&n),n!=-1)
    {
        for(int i=0;i<n;++i) P[i].input();
        Graham();
        printf("%.2f\n",solve());
    }
    return 0;
}
```

# 旋转卡壳——最小矩形覆盖
```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
#define N 50010
const double eps=1e-12;
struct Point{
    double x,y,angle;
    Point(){}
    Point(double _x,double _y):x(_x),y(_y){}
    void input()
    {
        scanf("%lf%lf",&x,&y);
    }
    void output()
    {
        printf("%.5f %.5f\n",x+eps,y+eps);
    }
    void f(double &a,double &b)
    {
        a=x;b=y;
    }
    bool operator<(const Point &a)const
    {
        return y<a.y||y==a.y&&x<a.x;
    }
    Point operator-(const Point &a)const
    {
        return Point(x-a.x,y-a.y);
    }
    double operator*(const Point &a)const
    {
        return x*a.x+y*a.y;
    }
    bool operator!=(const Point &a)const
    {
        return x!=a.x||y!=a.y;
    }
    Point operator+(const Point &a)const
    {
        return Point(x+a.x,y+a.y);
    }
}P[N],sta[N],Q[5];
//Q数组记录最小矩形的四个点
int n;
const double inf=1e20;
double cross(Point p0,Point p1,Point p2)
{
    return (p1.x-p0.x)*(p2.y-p0.y)-(p2.x-p0.x)*(p1.y-p0.y);
}
void Graham()
{
    sort(P,P+n);
    int cnt=0;
    for(int i=1;i<n;++i)
        if(P[i]!=P[i-1]) P[++cnt]=P[i];
    int top=1;
    sta[0]=P[0];sta[1]=P[1];
    for(int i=2;i<=cnt;++i)
    {
        while(top&&cross(sta[top-1],sta[top],P[i])>-eps) --top;
        sta[++top]=P[i];
    }
    int k=top;
    for(int i=cnt-1;i>=0;--i)
    {
        while(top>k&&cross(sta[top-1],sta[top],P[i])>-eps) --top;
        sta[++top]=P[i];
    }
    if(top) --top;
    for(int i=0;i<=top;++i) P[i]=sta[i];
    n=top+1;
}
double dis(Point p1,Point p2)
{
    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));
}
double dis_lp(Point p1,Point p2,Point p3)
{
    return fabs(cross(p1,p2,p3))/dis(p1,p2);
}
Point intersect(Point p1,Point p2,Point p3)//过点p3与向量p1p2垂直的向量与直线p1p2的交点
{
    double x1,x2,x3,y1,y2,y3,d,dx,dy,a1,b1,c1,a2,b2,c2;
    p1.f(x1,y1);p2.f(x2,y2);p3.f(x3,y3);
    a1=x2-x1;b1=y2-y1;c1=x3*(x2-x1)+y3*(y2-y1);
    a2=y2-y1;b2=x1-x2;c2=x1*y2-x2*y1;
    d=a1*b2-a2*b1;dx=c1*b2-c2*b1;dy=a1*c2-a2*c1;
    return Point(dx/d,dy/d);
}
double solve()
{
    P[n]=P[0];
    int i1=0,i2=0;
    for(int i=1;i<n;++i)
    {
        if(P[i].y<P[i1].y) i1=i;
        if(P[i].y>P[i2].y) i2=i;
    }
    int i3=i1+1,i4=i2+1;
    double ans=inf,a,h;
    for(int i=0;i<n;++i)
    {
        while(cross(P[i1],P[i2],P[i1+1])-cross(P[i1],P[i2+1],P[i1+1])<-eps)
            i2=(i2+1)%n;
        h=dis_lp(P[i1],P[i1+1],P[i2]);
        while((P[i1+1]-P[i1])*(P[i3+1]-P[i3])>eps) i3=(i3+1)%n;
        while((P[i1+1]-P[i1])*(P[i4+1]-P[i4])<-eps) i4=(i4+1)%n;
        a=fabs((P[i1+1]-P[i1])*(P[i3]-P[i4]))/dis(P[i1+1],P[i1]);
        if(ans>a*h)
        {
            ans=a*h;
            Q[0]=intersect(P[i1],P[i1+1],P[i3]);
            Q[1]=intersect(P[i1],P[i1+1],P[i4]);
            Point p=P[i2]+(P[i1]-P[i1+1]);
            Q[2]=intersect(P[i2],p,P[i3]);
            Q[3]=intersect(P[i2],p,P[i4]);
        }
        i1=(i1+1)%n;
    }
    return ans;
}
bool cmp(Point p1,Point p2)
{
    return p1.angle<p2.angle;
}
int main()
{
    scanf("%d",&n);
    for(int i=0;i<n;++i) P[i].input();
    Graham();
    if(n==1)
    {
        printf("%.5f\n",0);
        for(int i=1;i<=4;++i)
            P[0].output();
    }
    else if(n==2)
    {
        printf("%.5f\n",0);
        sort(P,P+1);
        P[0].output();P[0].output();
        P[1].output();P[1].output();
    }
    else
    {
        printf("%.5f\n",solve()+eps);
        sort(Q,Q+4);
        for(int i=1;i<4;++i)
            Q[i].angle=atan2(Q[i].y-Q[0].y,Q[i].x-Q[0].x);
        sort(Q+1,Q+4,cmp);
        for(int i=0;i<4;++i)
            Q[i].output();
    }
}
```

# 两圆的面积交
```
#include <iostream>
#include <cmath>
#include <algorithm>
#include <iomanip>
using namespace std;
typedef long double ld;
const ld pi=acosl(-1.0L);
ld area(ld x,ld y,ld r,ld xx,ld yy,ld rr)
{
    if(r>rr) swap(r,rr);
    ld d=sqrtl((x-xx)*(x-xx)+(y-yy)*(y-yy));
    if(d>=r+rr) return 0;
    if(d<=rr-r) return pi*r*r;
    ld k=acosl((r*r+d*d-rr*rr)/(d*r*2));
    ld kk=acosl((rr*rr+d*d-r*r)/(d*rr*2));
    return r*r*k+rr*rr*kk-sinl(k)*(r*r+d*d-rr*rr)/(2*d)*r-sinl(kk)*(rr*rr+d*d-r*r)/(2*d)*rr;
}
int main()
{
    ld x,x0,y,y0,r,r0;
    cin>>x>>y>>r>>x0>>y0>>r0;
    cout.precision(20);
    cout<<fixed<<area(x,y,r,x0,y0,r0)<<endl;
    return 0;
}
```

# 三维凸包+多面体重心
```
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;
#define N 1010
const double eps=1e-8;
const double inf=1e20;
struct TPoint{
    double x,y,z;
    TPoint(){}
    TPoint(double _x,double _y,double _z):x(_x),y(_y),z(_z){}
    TPoint operator-(const TPoint &p)const//向量相减
    {
        return TPoint(x-p.x,y-p.y,z-p.z);
    }
    TPoint operator^(const TPoint &p)const//向量叉积
    {
        return TPoint(y*p.z-z*p.y,z*p.x-x*p.z,x*p.y-y*p.x);
    }
    double operator*(const TPoint &p)const//向量点积
    {
        return x*p.x+y*p.y+z*p.z;
    }
    TPoint operator+(const TPoint &p)const//向量加法，求重心是调用
    {
        return TPoint(x+p.x,y+p.y,z+p.z);
    }
    TPoint operator/(const double k)const//向量除一个数，求重心是调用
    {
        return TPoint(x/k,y/k,z/k);
    }
    TPoint operator*(const double k)const//向量乘一个数，求重心时调用
    {
        return TPoint(x*k,y*k,z*k);
    }
    void input()
    {
        scanf("%lf%lf%lf",&x,&y,&z);
    }
    void output()//用来测试
    {
        printf("%.3f %.3f %.3f\n",x,y,z);
    }
};
double dis(TPoint p1,TPoint p2)//求重心时调用
{
    TPoint p=p1-p2;
    return sqrt(p1.x*p2.x+p1.y*p2.y+p1.z*p2.z);
}
struct Fac{
    int a,b,c;//凸包一个面上的三个点的编号
    bool ok;//该面是否是最终凸包中的面
};
struct T3dhull{
    int n;//初始点数
    TPoint P[N];//初始点
    int trianglecnt;//凸包上三角形数
    Fac tri[N*8];//凸包三角形
    int belong[N][N];//点i到点j是属于哪个面
    double vlen(TPoint p)//向量长度
    {
        return sqrt(p.x*p.x+p.y*p.y+p.z*p.z);
    }
    double volume(TPoint a,TPoint b,TPoint c,TPoint p)//四面体有向体积
    {
        return ((b-a)^(c-a))*(p-a)/6;
    }
    double ptoplane(TPoint &p,Fac &f)//点在面同的正向
    {
        TPoint p1=P[f.b]-P[f.a],p2=P[f.c]-P[f.a],p3=p-P[f.a];
        return (p1^p2)*p3;
    }
    void deal(int p,int a,int b)
    {
        int f=belong[a][b];//与当前面（cnt）共边（ab）的那个面
        Fac add;
        if(tri[f].ok)
        {
            //如果p点能看到面f，则继续深度搜索f的三条边，以便更新新的凸包面
            if(ptoplane(P[p],tri[f])>eps) dfs(p,f);
            else//否则p点只看到cnt面，看不到f面，则p点和a、b点组成一个三角形
            {
                add.a=b;add.b=a;add.c=p;add.ok=1;
                belong[p][b]=belong[b][a]=belong[a][p]=trianglecnt;
                tri[trianglecnt++]=add;
            }
        }
    }
    void dfs(int p,int cnt)//p点的凸包外时更新凸包
    {
        tri[cnt].ok=0;//删除当前面
        //下面把边反过来，处理与当前面相邻的面
        deal(p,tri[cnt].a,tri[cnt].c);
        deal(p,tri[cnt].c,tri[cnt].b);
        deal(p,tri[cnt].b,tri[cnt].a);
    }
    bool same(int s,int e)//判断两个面是否为同一面
    {
        TPoint a=P[tri[s].a],b=P[tri[s].b],c=P[tri[s].c];
        return fabs(volume(a,b,c,P[tri[e].a]))<eps
            &&fabs(volume(a,b,c,P[tri[e].b]))<eps
            &&fabs(volume(a,b,c,P[tri[e].c]))<eps;
    }
    void construct()//构建凸包
    {
        trianglecnt=0;
        if(n<4) return;
        bool tmp=true;
        for(int i=1;i<n;++i)//前两点不共点
            if(vlen(P[0]-P[i])>eps)
            {
                swap(P[1],P[i]);tmp=false;break;
            }
        if(tmp) return;
        tmp=true;
        for(int i=2;i<n;++i)//前三点不共线
            if(vlen((P[0]-P[1])^(P[i]-P[0]))>eps)
            {
                swap(P[2],P[i]);tmp=false;break;
            }
        if(tmp) return;
        tmp=true;
        for(int i=3;i<n;++i)//前四点不共面
            if(fabs(volume(P[0],P[1],P[2],P[i]))>eps)
            {
                swap(P[3],P[i]);tmp=false;break;
            }
        if(tmp) return;
        Fac add;
        for(int i=0;i<4;++i)//构建初始四面体
        {
            add.a=(i+1)%4,add.b=(i+2)%4,add.c=(i+3)%4,add.ok=1;
            if(ptoplane(P[i],add)>0) swap(add.b,add.c);
            belong[add.a][add.b]=belong[add.b][add.c]=belong[add.c][add.a]=trianglecnt;
            tri[trianglecnt++]=add;
        }
        for(int i=4;i<n;++i)//构建新凸包
        {
            for(int j=0;j<trianglecnt;++j)
            //判断点i能否看到面j
                if(tri[j].ok&&ptoplane(P[i],tri[j])>eps)
                {
                    //如果能看到则遍历面j和其他i点可见的面
                    dfs(i,j);break;
                }
        }
        int cnt=trianglecnt;
        trianglecnt=0;
        //保存最终得到的凸包
        for(int i=0;i<cnt;++i)
            if(tri[i].ok) tri[trianglecnt++]=tri[i];
    }
    double min_dis(TPoint p)//凸包中点p到凸包的最短距离
    {
        double ans=inf,V,S,H;
        for(int i=0;i<trianglecnt;++i)
        {
            V=fabs(volume(P[tri[i].a],P[tri[i].b],P[tri[i].c],p));
            S=vlen((P[tri[i].b]-P[tri[i].a])^(P[tri[i].c]-P[tri[i].a]))/2;
            H=3*V/S;
            ans=min(ans,H);
        }
        return ans;
    }
    bool f[N];//标记是否与其它面共面
    int face_num()//计算凸包有多少个面
    {
        memset(f,0,sizeof(f));
        int num=0;
        for(int i=0;i<trianglecnt;++i)
            if(!f[i])
            {
                ++num;
                for(int j=i+1;j<trianglecnt;++j)
                //标记与i共面的面
                    if(same(i,j)) f[j]=true;
            }
        return num;
    }
    TPoint center()//三维凸包重心
    {
        TPoint p(0,0,0),o(0,0,0);
        double sum_v=0,V;
        for(int i=0;i<trianglecnt;++i)
        {
            V=-volume(P[tri[i].a],P[tri[i].b],P[tri[i].c],o);
            p=p+(o+P[tri[i].a]+P[tri[i].b]+P[tri[i].c])/4.0*V;
            sum_v+=V;
        }
        return p/sum_v;
    }
}hull;
int main()
{
    while(scanf("%d",&hull.n)!=EOF)
    {
        for(int i=0;i<hull.n;++i)//输入点集
            hull.P[i].input();
        hull.construct();//构建凸包
        TPoint p=hull.center();//求凸包重心
        printf("%.3f\n",hull.min_dis(p));
    }
    return 0;
}
```

# 圆的面积并
```
/*
两个剪枝。

首先把所有被内含的圆删掉。

其次我们可以一段一段的求simpson值，累加。

因为中间可能会有空的部分。
*/
#include<math.h>
#include<stdio.h>
#include<string.h>
#include<algorithm>
#define N 1100
#define pr pair<double,double>
#define Fabs(x) ((x)>0?(x):-(x))
using namespace std;
const double pi=acos(-1.0);
const double EPS=1e-13;
const double INF=1e100;
struct Point
{
    int x,y;
    friend double dis(Point a,Point b)
    {
        return sqrt((double)(a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
    }
};
struct Circle
{
    Point p;
    int r;
    void read(){scanf("%d%d%d",&p.x,&p.y,&r);}
    friend bool operator <(Circle a,Circle b)
    {
        if(a.p.x-a.r<b.p.x-a.r)
            return a.p.x+a.r<b.p.x+a.r;
        return a.p.x-a.r<b.p.x-a.r;
    }
    pr f(double x)
    {
        if(r<=fabs(p.x-x))  return pr(0,0);
        double t=r*r-(p.x-x)*(p.x-x);
        t=sqrt(t);
        return pr(p.y-t,p.y+t);
    }
}O[N];
bool ban[N];
pr p[N];
int n;
double Cut(double x)
{
    double ret=0,last=-INF;
    int cnt=0;
    for(int i=1;i<=n;i++)
    {
        p[++cnt]=O[i].f(x);
        if(p[cnt]==pr(0,0))
            cnt--;
    }
    sort(p+1,p+cnt+1);
    for(int i=1;i<=cnt;i++)
    {
        if(p[i].first>last)
            ret+=p[i].second-p[i].first,last=p[i].second;
        else if(p[i].second>last)
            ret+=p[i].second-last,last=p[i].second;
    }
    return ret;
}
double Simpson(double l,double r,double mid,double Cl,double Cr,double Cm)
{
    double tCl=Cut((l+mid)/2),tCr=Cut((mid+r)/2);
    double ans=(r-l)*(Cl+Cr+4*Cm)/6,lans=(mid-l)*(Cl+Cm+4*tCl)/6,rans=(r-mid)*(Cr+Cm+4*tCr)/6;
    if(Fabs(lans+rans-ans)<EPS)
        return ans;
    else
        return Simpson(l,mid,(l+mid)/2,Cl,Cm,tCl)+Simpson(mid,r,(mid+r)/2,Cm,Cr,tCr);
}
int main()
{
    int i,j,k;
    double l,r;
    scanf("%d",&n);
    l=INF,r=-INF;
    for(i=1;i<=n;i++)
    {
        O[i].read();
        l=min(l,(double)O[i].p.x-O[i].r);
        r=max(r,(double)O[i].p.x+O[i].r);
    }
    sort(O+1,O+n+1);
    for(i=1;i<=n;i++)
    {
        if(ban[i])  continue;
        for(j=i+1;j<=n;j++)
        {
            if(ban[j])  continue;
            if(dis(O[i].p,O[j].p)+O[j].r<=O[i].r)
                ban[j]=1;
        }
    }
    for(i=1;i<=n;i++)
    {
        if(ban[i])
        {
            swap(ban[i],ban[n]);
            swap(O[i--],O[n--]);
        }
    }
    printf("%.3lf\n",Simpson(l,r,(l+r)/2,0,0,Cut((l+r)/2)));
    return 0;
}
```

# 多边形面积的交与并
```
/*
 * 多边形的交，多边形的边一定是要按逆时针方向给出
 * 还要判断是凸包还是凹包，调用相应的函数
 * 面积并，只要和面积减去交即可
 */  
#include <bits/stdc++.h>  
using namespace std;  

const int maxn = //300;  
const double eps = 1e-8;  
int dcmp(double x)  
{  
    if(x > eps) return 1;  
    return x < -eps ? -1 : 0;  
}  
struct Point  
{  
    double x, y;  
};  
double cross(Point a,Point b,Point c) ///叉积  
{  
    return (a.x-c.x)*(b.y-c.y)-(b.x-c.x)*(a.y-c.y);  
}  
Point intersection(Point a,Point b,Point c,Point d)  
{  
    Point p = a;  
    double t =((a.x-c.x)*(c.y-d.y)-(a.y-c.y)*(c.x-d.x))/((a.x-b.x)*(c.y-d.y)-(a.y-b.y)*(c.x-d.x));  
    p.x +=(b.x-a.x)*t;  
    p.y +=(b.y-a.y)*t;  
    return p;  
}  
//计算多边形面积  
double PolygonArea(Point p[], int n)  
{  
    if(n < 3) return 0.0;  
    double s = p[0].y * (p[n - 1].x - p[1].x);  
    p[n] = p[0];  
    for(int i = 1; i < n; ++ i)  
        s += p[i].y * (p[i - 1].x - p[i + 1].x);  
    return fabs(s * 0.5);  
}  
double CPIA(Point a[], Point b[], int na, int nb)//ConvexPolygonIntersectArea  
{  
    Point p[20], tmp[20];  
    int tn, sflag, eflag;  
    a[na] = a[0], b[nb] = b[0];  
    memcpy(p,b,sizeof(Point)*(nb + 1));  
    for(int i = 0; i < na && nb > 2; i++)  
    {  
        sflag = dcmp(cross(a[i + 1], p[0],a[i]));  
        for(int j = tn = 0; j < nb; j++, sflag = eflag)  
        {  
            if(sflag>=0) tmp[tn++] = p[j];  
            eflag = dcmp(cross(a[i + 1], p[j + 1],a[i]));  
            if((sflag ^ eflag) == -2)  
                tmp[tn++] = intersection(a[i], a[i + 1], p[j], p[j + 1]); ///求交点  
        }  
        memcpy(p, tmp, sizeof(Point) * tn);  
        nb = tn, p[nb] = p[0];  
    }  
    if(nb < 3) return 0.0;  
    return PolygonArea(p, nb);  
}  
double SPIA(Point a[], Point b[], int na, int nb)///SimplePolygonIntersectArea 调用此函数  
{  
    int i, j;  
    Point t1[4], t2[4];  
    double res = 0, num1, num2;  
    a[na] = t1[0] = a[0], b[nb] = t2[0] = b[0];  
    for(i = 2; i < na; i++)  
    {  
        t1[1] = a[i-1], t1[2] = a[i];  
        num1 = dcmp(cross(t1[1], t1[2],t1[0]));  
        if(num1 < 0) swap(t1[1], t1[2]);  
        for(j = 2; j < nb; j++)  
        {  
            t2[1] = b[j - 1], t2[2] = b[j];  
            num2 = dcmp(cross(t2[1], t2[2],t2[0]));  
            if(num2 < 0) swap(t2[1], t2[2]);  
            res += CPIA(t1, t2, 3, 3) * num1 * num2;  
        }  
    }  
    return res;  
}  
Point p1[maxn], p2[maxn];  
int n1, n2;  
int main()  
{  
    while(cin>>n1>>n2)  
    {  
        for(int i = 0; i < n1; i++) scanf("%lf%lf", &p1[i].x, &p1[i].y);  
        for(int i = 0; i < n2; i++) scanf("%lf%lf", &p2[i].x, &p2[i].y);  
        double Area = SPIA(p1, p2, n1, n2);  
    }  
    return 0;  
}  
```

# 坐标旋转公式
```
假设对图片上任意点(x,y)，绕一个坐标点(rx0,ry0)逆时针旋转a角度后的新的坐标设为(x0, y0)，有公式：

    x0= (x - rx0)*cos(a) - (y - ry0)*sin(a) + rx0 ;

y0= (x - rx0)*sin(a) + (y - ry0)*cos(a) + ry0 ;
```

# 皮克定理
```
皮克定理是指一个计算点阵中顶点在格点上的多边形面积公式，该公式可以表示为2S=2a+b-2，其中a表示多边形内部的点数，b表示多边形边界上的点数，s表示多边形的面积。
```
